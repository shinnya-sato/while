----------------------------------------------------------------

  While言語のインタプリタ

      佐藤伸也
      shinya.sato.mito@vc.ibaraki.ac.jp

----------------------------------------------------------------

1. whileプログラムのインタプリタ

書籍「チューリングの考えるキカイ ～人工知能の父に学ぶコンピュータ・サイエンスの基礎」
（阿部彩芽・笠井琢美 著、技術評論社）で導入されている whileプログラムのインタプリタです。
なお、このプログラムは書籍のファンである作者が勝手に作成したものであり、
書籍の著者ら、出版社とはなんの関係もありません。

書籍のサイト：https://gihyo.jp/book/2018/978-4-7741-9689-3


1-1. 特徴
- 実行結果がすぐにわかります！
 - プログラムを入力して実行ボタンを押すだけで、
 　すぐに結果が表示されます。いろいろなおまじないは必要ありません。

 - 実行結果と一緒に変数の値も表示されます。
　 print で表示しなくても簡単にわかります。

- 途中経過も簡単にわかります！
 - 1行ずつ実行できますので、実行順番が目で追えます。



1-2. 必要環境

動作確認は以下の環境で行っています
（Python3 はもっと低いバージョンでも動くと思います）:

- Windows 10(64bit), Python 3.7.7
- Ubuntu 20.04.2 LTS, Python 3.8.5


ソースの実行には Python ライブラリ PySide2、PLY(Python Lex-Yacc) が必要です。
pip コマンドで前もってインストールしてください：
 pip install pyside2 ply


1-3. 実行方法
Python3 にて MainWindow.pyw を実行してください：
 python3 MainWindow.pyw
 

1-3-1. Windows10 向け実行ファイル

Windows10(64bit)版向けにコンパイル済みの実行ファイル
while-v1.3.9-release-Win10-64bit.zip を用意しています。
下記リンクから入手できます：
https://github.com/shintan310/while-interpreter/releases/download/v1.3.9-release/while-v1.3.9-release-Win10-64bit.zip



----------------------------------------------
2. 使ってみましょう

アプリの画面には2つのテキストアリアがあります：

- 背景が白い方にプログラムを入力します。
- 灰色のものには実行結果が表示されます。


背景が白い方に whileプログラム「print(23)」を入力し、
画面上側にある「▶」ボタンを押してみましょう。
プログラムが実行され、実行結果のところに「23」と表示されます。

なお、正しく入力されていないときにはエラーが表示されますので、
訂正してもう一度「▶」ボタンを押してください。

複数の文を実行するときには複合文 begin ～ end を使います。
例えば、変数 x に 23+10 の結果を代入し、x の値を表示するには
例1のようにプログラムの行を ; で区切って入力します。
実行すると「33」と表示されるはずです。

（なお、begin 〜 end の最後の行の文末、
ここでは print(x) の文末に ; を付ける必要はありませんが、
 ; を付けてもエラーにならないようにしています。
 区別が大変なときには、文末に ; を付けると覚えておいてください）


--- 例1 ----------
begin
    x:=23+10;
    print(x);
end
------------------


行頭の半角スペースは無くても結構ですが、
begin ～ end で囲まれていることが分かりやすいように
インデント（字下げ）をすると良いです。
Tabキーを押すと半角スペース 4文字分が自動的に入力できますので、
インデントに便利です（Shift+Tab でインデントをキャンセルできます）。


print文で複数の変数の値を表示したいときには、
カンマ「,」で区切って変数名を指定してください（例2）：

--- 例2 ----------
begin
    x:=23;
    y:=x+10;
    print(x,y);
end
------------------

※プログラムの実行は、「▶」ボタンの代りに
キーボードショートカット Ctrl+Enter でも行えます。




----------------------------------------------
3. 書籍のプログラム表記との違い

[変数名]
- 変数名は x0、x1、x2、... だけでなく、
　英字から開始する英数字が使えます。
　例えば、a、a1、result などが使えます。


[代入、四則演算の記号]
- 演算子にはすべて半角記号を使います：
  - 代入記号は「←」の代わりに「:=」を使います。
  - 「≠」には 「!=」 を使います。 
  - 「＞」には 「>」 を使います。
  - 「≧」には 「>=」 を使います。
  - 「＜」には 「<」 を使います。
  - 「≦」には 「<=」 を使います。


- 四則演算には +, -, *, div が使えます
（組み込み演算として実装しています）。
また、割り算の余りには mod が使えます。


[文]
- 行中の # から右のものはコメントとして扱われ、
プログラムとしては解釈されません。

- whileプログラムの文として「空文」を認めています。そのため、複合文
  「begin s1;s2; ... ;sm end」
  を、
  「begin s1;s2; ... ;sm; end」
として書けます
（つまり、最後の文 sm にセミコロンを付けてもエラーになりません）。


- whileプログラムの文は 1行で書いてください。
　行末に \を付けると次の行と同じ行として解釈されるようにしていますが、
　たくさんの文を書くときには複合文 begin ～ end を使いますので、
　begin ～ endの間は改行しても1行として解釈されるようにしています。
　なお、begin ～ end の間は、改行しても1行の文として解釈されます。


[配列]
- 配列には鍵かっこを使います。例えば、3,6,8 を要素とする配列は
  [3,6,8]
  と書きます。


[文字、文字列]
- 文字、文字列は「"」で囲みます。例えば、文字列 hello は
  "hello"
と書きます。文字列の同一性は「=」を用いて判定できます。


[手続き]
- 書籍では、手続きがマクロ（構文糖）として導入されていますが、
　いわゆる普通のプログラミング言語の「手続き」として実装しています。
　なお、書籍での動作と合わせるため、引数に変数名を指定したときには
　手続き内での変更が呼び出し元にも反映されるようにしています。 
　例えば、次に示す手続き foo によって、変数 x は 11 になります：

procedure z:= foo(a): begin
    a++;
    z:=a*10;
end

begin
    x:=10;
    z:=foo(x);
    print(x, z);  # 11, 110 になるはず
end


　手続きの引数として変数を指定すると
　手続き内で行われた変更がその変数にも反映されますので、
　引数に与えられた変数の値を交換する手続き swap は次のように書けます：

procedure z:=swap(a,b): begin
    tmp:=a;
    a:=b;
    b:=tmp;
end

begin
    x:=1;
    y:=20;
    z:=swap(x,y);
    print(x,y);  # 20 1 となるはず
end



-----------------------------
3.1 拡張機能
-----------------------------

[文字列]
- 数値から文字列への変換には組み込み手続き str、
　文字列から数値への変換には組み込み手続き int を使ってください
　（自然数しか扱えませんが、慣例的に int を使うことにしています）。

- 文字列の連結には「+」を使ってください。例えば、"abc" と "xyz" を連結する場合には、
　 "abc" + "xyz"
　と書きます。この結果は "abcxyz" となります。
　文字列と自然数を連結させるときには、
　自然数を文字列にしてから「+」で連結します。例えば、
　"abc" に 123 を連結させるときには
　"abc" + str(123)``` と書きます。連結の結果は "abc123" となります。
　なお、文字列と自然数も「+」で連結できます。例えば、"abc" + 123
　の結果は、"abc123" となります。		  

- 部分文字列取得には left, right, mid が使えます（組み込み手続きとして実装してます）：
 - left(str, n)    str の左から n 文字を取得します。
 - right(str, n)   str の左から n 文字を取得します。
 - mid(str, n, m)  str の左から数えて n 文字目から m文字分を取得します。

begin
    moji:="abcdefg";
  
    x:=left(moji, 3);   # "abc" 
    y:=right(moji, 3);  # "efg"
    z:=mid(moji, 2, 4); # "bcde"

    print(x,y,z);  # "abc" "efg" "bcde" となるはず
end


[文字列の長さ（文字数）、配列の長さ（要素数）]
- 文字列の長さ（文字数）の取得、配列の長さ（要素数）の取得には
　手続き len を使ってください（組み込み手続きとして実装しています）。

begin
  # "abc" は3文字の文字列なので、x には 3 が代入される
  x:=len("abc");

  # 配列 [1,1,1,1] の要素数は 4 つなので、y には 4 が代入される
  y:=len([1,1,1,1]);

  print(x,y); # 3, 4 となるはず
end



----------------------------------------------
4. プログラムのサンプル

-----------------------------
4.1 引数に与えられえた値を一つ増やす
-----------------------------

# 引数に与えられた値を一つ増やす
procedure z:= oneUp(a): begin
    b:=a;
    b++;
    z:=b;
end

begin
    x:=100;
    z:=oneUp(x);
    print(z);   # 101 が表示されるはず
    print(x);   # 100 が表示されるはず

    # ちなみに、procedure は式として扱われるようにしてあるので
    # print(oneUp(200)) として実行すると 201 が返ってくる
    print(oneUp(200))
end


-----------------------------
4.2 素数判定
-----------------------------

# 素数判定
procedure  z:= isPrime(n): begin
    z:=1;
    w:=2;  # 2 から始めて n まで検査する
    
    while (w < n) and (z=1) do begin
  
        # 割り切れるときは素数でないので終了
        if (n mod w)=0 then z:=0;

        w++;
    
    end
end

begin
    z:=isPrime(3);
    print(z);       # 1 が表示されるはず
    
    z:=isPrime(4);
    print(z)        # 0 が表示されるはず
end



-----------------------------
4.3 n番目の素数を求める
-----------------------------

# n が素数かどうかを判定する
procedure  z:= isPrime(n): begin
    z:=1;
    w:=2;
    while (w < n) and (z=1) do begin
        if (n mod w)=0 then z:=0;
        w++;
    end
end


# n 番目の素数を取得する
procedure  z:= getPrime(n): begin
    hit:=0;  # 素数を見つけた回数
    z:=2;
    
    while (hit < n) do begin
        z++;
        kekka:=isPrime(z);

        # z が素数ならば、素数ゲットで hit++
        if kekka=1 then hit++;
    end
end

begin
    z:=getPrime(5);
    print(z);       # 13 が表示されるはず
end



-----------------------------
4.4 チューリングマシン（単能）
-----------------------------

命令表
|条件 |     |      | 動作 |     |
|---  | --- | ---  | ---  | --- |
|q0   | 1   | →   | q1   | ␣  |
|q1   | ␣  | →   | q2   | 右  |
|q2   | 1   | →   | q1   | ␣  |

テープの初期状態
|▷ | 1 | 1 | 1 |

ヘッド位置:1（「▷」のところ）

ヘッドの内部状態:q0


# プログラム開始
begin
    # 初期状態の設定

    x0:=["▷", "1", "1", "1"];  # テープ
    h:=1;  # ヘッド位置
    q:=0;  # ヘッドの内部状態

    # 実行開始
    active:=1;  # ループの番人
    
    while (active=1) do begin
        print(x0, h, q);
        
        # テープ上の記号を読み込む
        kigou := x0[h];
        
        # 命令表に従った動作を行う
        if (q=0) and (kigou="1") then begin
            q:=1;  x0[h] := "␣" 
        end
        else if (q=1) and (kigou="␣") then begin
            q:=2;  h++ 
        end
        else if (q=2) and (kigou="1") then begin
            q:=1;  x0[h]:="␣" 
        end
        else  active := 0  # どれにも該当しないときは終了させる
    end
end


# 実行するとこのような出力になる
# ["▷", "1", "1", "1"] 1 0
# ["▷", "␣", "1", "1"] 1 1
# ["▷", "␣", "1", "1"] 2 2
# ["▷", "␣", "␣", "1"] 2 1
# ["▷", "␣", "␣", "1"] 3 2
# ["▷", "␣", "␣", "␣"] 3 1
# ["▷", "␣", "␣", "␣"] 4 2






-----------------------------
4.5 バブルソート
-----------------------------
# バブルソート
begin
    list := [6,9,8,4,2];
  
    # どの要素まで処理するか
    kokomade := len(list)-1;
    
    while kokomade>0 do begin

        i:=0;
        while i<kokomade do begin
            # 0 から kokomade までを処理する
    
            if list[i] > list[i+1] then begin
                # list[i] の方が大きいので、i+1 の要素と取り換える
                tmp := list[i];
                list[i] := list[i+1];
                list[i+1] := tmp;
            end;
      
            i++;
        end;
    
        kokomade--;
    end;

    print(list)  # [2, 4, 6, 8, 9] になるはず
end


-----------------------------
4.6 リストの連結
-----------------------------
procedure z:=append(a,b): begin
    length_a := len(a);
    length_b := len(b);
    
    z := a;
    i := 0;
    while i<length_b do begin
        z[length_a + i] := b[i];
        i++;
    end;
end

begin
    ret:=append([10,12], [4,5,6]);
    print(ret)  # [10,12,4,5,6] になるはず
end


-----------------------------
4.7 階乗（再帰関数の例です）
-----------------------------

# 階乗
procedure z:=fact(n): begin
    if n=0 then begin
        z:=1
    end
    else begin
         z1:=fact(n-1);
         z := n*z1;
    end
end

begin
    z:=fact(3);
    print(z)      # 6のはず
end



-----------------------------
4.8 クイックソート
-----------------------------
procedure z:=append(a,b): begin
    length_a := len(a);
    length_b := len(b);
    
    z := a;
    i := 0;
    while i<length_b do begin
        z[length_a + i] := b[i];
        i++;
    end;
end

procedure z:=quicksort(list): begin
    length := len(list);
    if length = 0 then begin
        z:=list;
    end
    else begin
        pivot := list[0];
        list1 := [];  list1_index := 0;
        list2 := [];  list2_index := 0;
        i := 1;
        while i<length do begin
            if list[i] < pivot then begin
                list1[list1_index]:=list[i];
                list1_index++;
            end
            else begin
                list2[list2_index]:=list[i];
                list2_index++;                
            end;
            i++;            
        end;
        sorted1 := quicksort(list1);
        sorted2 := quicksort(list2);
        z:=append(sorted1, [pivot]);
        z:=append(z,sorted2);
                                    
    end    
end


begin
    ret:=quicksort([5,10,4,12,1,6]);
    print(ret)  # [1, 4, 5, 6, 10, 12] になるはず
end


-----------------------------
4.9 クイックソート
　リストを + で連結する簡単版
-----------------------------
procedure z:=quicksort(list): begin
    length := len(list);
    if length = 0 then begin
        z:=list;
    end
    else begin
        list1 := [];
        list2 := [];        
        pivot := list[0];
        
        i := 1;
        while i<length do begin
            val := list[i];
            if val < pivot then begin
                list1:= list1 + [val];
            end
            else begin
                list2:= list2 + [val];
            end;
            i++;            
        end;
        sorted1 := quicksort(list1);
        sorted2 := quicksort(list2);
        z:=sorted1 + [pivot] + sorted2;
                                    
    end    
end


begin
    ret:=quicksort([5,10,4,12,1,6]);
    print(ret)  
end


-----------------------------
4.10 whileプログラムのインタプリタ eval
-----------------------------

#なお、与えるプログラムはあらかじめ構文木に変換しておく
# xi++ => ["incx", i]
# xi-- => ["decx", i]
# begin s1;...;sn end => ["multi", n, [s1,...,sn]]
# while xi != 0 do s  => ["while", i, s]

procedure z:=eval(s, env): begin

    # s[0] に文の識別子（"incx", "decx"、"multi", "while"）
    # が入っているので、それに応じた動作を行う
    
    if s[0] = "incx" then begin
        # 変数番号を取得
        index := s[1];
        
        # 環境を更新（++ の操作）
        env[index] := env[index]+1
    end
    else if s[0] = "decx" then begin
        # 変数番号を取得
        index := s[1];
        
        # 環境を更新（-- の操作）
        env[index] := env[index]-1
    end
    else if s[0] = "multi" then begin
        # 複合文の処理
        
        length := s[1];  # 文の個数
        multis := s[2];  # 文の取得
    
        # 複合文の実行
        i := 0;
        while i<length do begin
            env := eval(multis[i], env);
            i++;
        end;
    end
    else begin
        # while文の処理
        
        cond_index := s[1];  # 'while xi ...' の i を取得
        sentence := s[2];    # 文を取得
        
        # while文の動作を行う
        while env[cond_index] != 0 do begin
          env := eval(sentence, env);
        end;
    
    end;

    # 採取結果が含まれる環境 env を戻り値にする
    z:=env
end


begin

    # 初期条件
    # P  : x0++
    # x0 : 10

    env := [10];
    print(env);
    env := eval(["incx", 0], env);
    print(env);  # [11] になるはず
    
    
    # 初期条件
    # P  : while x1 != 0 do begin x1--; x0++; x0++ end
    # x0 : 0
    # x1 : 10
    
    env := [0,10];
    print(env);
    env := eval(["while", 1, ["multi", 3, [["decx", 1], ["incx", 0], ["incx", 0]]]], env);
    print(env);  # [20,0] になるはず
end





-----------------------------
4.10 スタック構造
-----------------------------

# スタック構造
procedure z:=mkStack(): begin
    z:=[0,[0]]
end

procedure z:=isEmpty(s): begin
    if s[0]=0 then z:=1
    else z:=0
end

procedure z:=push(s,n): begin
    index := s[0];
    index++;
    vals := s[1];
    vals[index] := n;
    z := [index, vals];
end

procedure z:=pop(s): begin
    index := s[0];
    index--;
    z := [index, s[1]]
end

procedure z:=top(s): begin
    index := s[0]; 
    vals := s[1];
    z := vals[index] 
end


begin
    stack := mkStack();
    print(stack);  # [0, [0]]
    
    stack := push(stack, 100);
    print(stack);  # [1, [0, 100]]
    
    stack := push(stack, 38);
    print(stack);  # [2, [0, 100, 38]]
    
    z:=top(stack);
    print(z);  # 38
    
    stack := pop(stack);
    print(stack);  #  [1, [0, 100, 38]]  
      # 38 が残るが、参照先を示す stack[1] が 2 から 1 になっているので
      # スタック構造としては正しく機能できる

    z:=top(stack);
    print(z);  # 100  （このように、現在のトップに積まれている値が取得できる）
    
    z:=isEmpty(stack);
    print(z);  # 0
    
    stack := pop(stack);
    z:=isEmpty(stack);
    print(z);      # 1
    print(stack);  # [0, [0, 100, 38]] （ごみは残るが index が 0 であるため empty）
end


-----------------------------
4.11 階乗（スタックを用いた再帰なし版）
-----------------------------

# スタック構造
procedure z:=mkStack(): begin
    z:=[0,[0]]
end

procedure z:=isEmpty(s): begin
    if s[0]=0 then z:=1
    else z:=0
end

procedure z:=push(s,n): begin
    index := s[0];
    index++;
    vals := s[1];
    vals[index] := n;
    z := [index, vals];
end

procedure z:=pop(s): begin
    index := s[0];
    index--;
    z := [index, s[1]]
end

procedure z:=top(s): begin
    index := s[0]; 
    vals := s[1];
    z := vals[index] 
end


# 再帰なしの階乗
procedure z:=Fact(n): begin
    task := mkStack();
    retval := mkStack();
    
    # task スタックには [cnt, n] という形式で入れる
    # cnt は継続値（初期なら1, 2度目なら2）
    # n は、階乗計算の対象値（Fact(3) のときには n=3）
    task := push(task, [1, n]);
    sentinel := 0;
      
    while sentinel=0 do begin

        # タスクを一つ取得
        aTask := top(task);  
        task := pop(task);

        # 階乗計算の対象となる数を n に
        n := aTask[1];

        # 初期の処理(cnt=1)か、継続の処理(cnt=2)か
        cnt := aTask[0];
        if cnt=1 then begin
            if n=0 then      
                # 値用のスタックに 0! の結果である 1 を push
                retval := push(retval, 1)
	
            else begin
                # Fact(n-1) の後にもう一度処理（継続処理）させる
                task := push(task, [2, n]);

                # Fact(n-1) のために、新たなタスクを push する
                task := push(task, [1, n-1]);
            end
        end
        else begin
            # 継続処理用

            # 値用のスタックから一つ取得
            # なお、z1 には Fact(n-1) の結果が入っている
            z1 := top(retval);  retval := pop(retval);

            # 階乗を計算し、値用のスタックへ push しておく
            z := n * z1;
            retval := push(retval, z);
        end;

        # タスクスタックが空っぽなら終了
        sentinel := isEmpty(task);
    end;

    # 値用スタックに積んである結果を一つ取得し、戻り値にする
    z := top(retval)
end


# 実行
begin
    z:=Fact(4);
    print(z)     # 24 になるはず
end



----------------------------------------------
5. ライセンス

このディレクトリに含まれるソースコードは
すべて佐藤伸也が著作権を保持し、MITライセンスのもとで配布します。
コピー、配布、変更、再配布、商用利用など、ご自由に使ってください。
このソフトウェアにはなんの保証もついてきませんので、
利用したことで何か問題が起きたとしても作者はなんの責任も負いません。

佐藤伸也 / Shinya Sato





----------------------------------------------
6. 変更履歴

2021-07-15
- v1.3.10 としてリリース
- 環境表示のアニメーションで、有効な環境表示以外は disabled にした。



2021-07-14
- ディレクトリ構成を変更。MainWindow.pyw 以外は srcフォルダへ移動した。
- 特徴説明のための animation gif を追加。



2021-07-11
- v1.3.9 としてリリース
- コメントだらけだけれど、良い感じに仕上がってきたのでリリースです。
- 今回のリリースは、環境表示にアニメーションを適用したのが目玉
- 多分、やりたいことはできたので、次こそはメジャーアップデートで
　文法の整理をしたい。


2021-07-07
- 環境表示にもアニメーション効果を適用し、動作が分かりやすくなるようにしてみた。
-- 変数が新しく追加される tableWidget の cell には高さが延びるアニメ効果を加え、
　挿入されるイメージを演出した。
-- 手続きが呼び出されるときには環境が dump にスタックされることを
　イメージしやすくなるようにするため、
　現在の環境viewer の上に新しい viewer がスタック表示されるようにした。
　また、その出現をアニメーションでじわりと表示させるようにした。
-- 手続き呼び出しが終わるときには環境も消去されるため、
　そのイメージを掴むために disabled 表示にし、縮んで消去されるアニメ効果を導入した。
-- デバッグの rewrind、play でも正しく動作させるようにした
　（スタック表示版を想定しなくて作りこんでいたため、スタック版への変更に苦労した）。

- [TODO]
-- rewrind、play ボタンを連打するとアニメがついていかなく、
　環境のスタック操作と連動しなくなってしまう。
　==> アニメの間はボタンを無効化することで対処?...
　==> 2021-07-11 追記：VBoxlayout に widget の管理を任せていたのが原因。
      例えば、VBoxLayout.itemAt(0) としても、描画のタイミングで
      すでに削除された widget が itemAt(0) に居残りもありうる。
      widget_list というように自前で用意し、
      描画と内部管理を分離することで解決した。
-- 新しく作られる tableWidget の第1列幅が統一されていない
　==> tableWidget の幅をその都度設定すれば良いので、そのうち対応する。
　==> 2021-07-11 追記：使ってみて、必要だったら対処する
  
-- アニメーション効果が必要ない人用のトグルスイッチ作成



2021-07-05
- v1.3.8 としてリリース
- デバッグモードの「戻る」操作をしていると、手続き呼び出し前後で
環境が戻せないことがあった。手続きによる参照呼びのための思い付きの方法として
参照呼びの名前用スタックを使っていたが、どうもタイミングが合わないらしい。
なぜ合わないのかはわからないが、この操作を SECD の C に含めるようにして解消した。
- エラーメッセージをクリックすると、該当行へカーソルを自動で移動させるようにした
（本来はそうすべきだったと思う）。
- デバッグモードの環境表示にて、更新があった場合にはセル枠を光らせる
アニメーションを付けてみた。
- アニメーションの使い方が分かってきた。下記が詳しい：
https://www.mfitzp.com/tutorials/qpropertyanimation/


2021-07-04
- str("-1") で負数に変換されていた不具合を修正（負数のときは 0 にした）
- 検索、置換小窓を表示にアニメーション効果を付けた


2021-07-03
- v1.3.7 としてリリース
- 置換機能を実装し、編集メニューに加えた。
- [TODO エディタ関連]
  - エラー行を分かりやすく表示したい
  => 2021-07-05追記：
  　エラーメッセージをクリックすると該当行へフォーカスが移るようにした。


2021-07-02
- v1.3.6 としてリリース

- エディター画面で、選択領域作成後、すぐに解除される
不具合を解消した。エディターから myclicked signal が
出され、それを拾って「検索」widget を閉じて解除していたが、
「検索」widget が開かれてないときにも解除されていたのが原因。

- procedure に変数名を与えた時の挙動を勘違いしていたため修正。
procedure に変数名が与えられたときには、
procedure 実行後の環境の値が代入されるようにした。
確か、以前はこれで作成したけれど、参照呼びにすべきと
勘違いしてしまっていた。


2021-07-01
- 変数の初期状態設定ドックにコンテキストメニューを加え、
右クリックで設定行が削除できるようにした。



2021-06-28
- v1.3.5 としてリリース
- 検索機能を追加
- 変数の初期状態を設定できるようにした
- 将来の拡張を見据えて、one-step 実行 history に SECD を含めるようにした。
- [TODO]
-- 置換機能の実装
-- 文法の見直し（学習コストをなるべく低くする方針で）


2021-06-18
- v1.3.4 としてリリース
- メニュー周りの改善
- border が微妙に空いていたので margin:0 にした



2021-06-17
- v1.3.3 としてリリース
- デバッグでのハイライト表示をわかりやすくするため、
　前の行から次の行へのトレースアニメーションを加えてみた。


2021-06-16
- v1.3.2 としてリリース
- 負の値を文法エラーにした。
- () や [] のオートコンプリートを行末だけで有効にした。


2021-06-15
一応、これで完成版としたい。エディタ機能は、おいおい追加する。
次回は言語仕様を少し変更（例えば := ではなく = を使うなど）し
メジャーアップデートとする。

- v1.3.1 としてリリース
- 文末に \ があれば、行を継続するようにした。
- begin end の自動挿入が行われる条件を見直し、
　同じインデントレベルで既に end がある場合には補間しないようにした。
- 未保存のままで他のファイルを開くと、
　未保存の性質が引き継がれてしまっていた不具合を解消した
　（window タイトルを変更しただけでも modified とみなされてしまうらしい）。
- 実行時のハイライトを cursor.setBlockFormat で指定していたが、
　この指定によって modified と見なされてしまっていた。
　代わりに QTextEdit.ExtraSelection を使うことで modified が検出されないようにした。


2021-06-14

- v1.3 としてリリース
- whileプログラムの解釈に使っていたスタックの実行を見直し、
SECDマシン準拠となるようにした
（Stack に積む操作も Code に落とすようにした）。
これで、解釈エラーがポロポロと出なくなるはず。
- 名前呼びについても、adhoc に whileプログラムのコードを
入れ込むのではなく、引数と与えられた変数の参照関係を見るようにした
（なお、2連鎖以上は未実装）。
- len, left, right, mid, int, str を実装した。
- シンタックスハイライトを導入した。多分、見やすくなったと思う。
- begin と入力すると end が自動的に挿入されるようにした。
- 同様に、(), []、"" の自動挿入にも対応した。
- タブを使うのをやめ、すべてスペース4文字で置き換えるようにした。



2021-06-12
配列、文字列の長さを取得する関数 len を buit-in として実装した。
Shift+Tab でインデント操作ができるようにした。
選択領域に対しても Tab、Shift+Tab が行えるようにした。
改行をしたとき、前の行が `begin' で終わっているときには
自動的に \t を入れてインデントするようにした。



2021-06-11
演算子の結合の強さが PLY でうまく定義できていなかったので
修正した（1 < 5-2  が (1<5) - 2 と解釈されていた）。
ついでに IF-THEN-ELSE の shift/reduce conflict も解消した。
ドラッグ＆ドロップでファイルがオープンできるようにした。



2021-06-10
print文や深い array などで、式が与えられると
正しく評価されない不具合を解消した。


2021-06-09
ファイルメニューに「新規作成」などの定番操作を加え、
ツールバーにもそれらのアイコンを加えた。


2021-06-07
v1.2 としてリリース。
デバッグモード用のドッグを追加し、1行ずつ実行できるようにした。
Procedure への名前受け渡しの不具合を修正した。
深い配列（例えば a[2][1][4] など）への代入の不具合を修正した。


2021-05-29
まだ使われていない変数 a に対して a++ が実行されると
環境の参照エラーになってしまうバグを修正した。

Evaluator クラスを作成した。
しかし、ply の lexer でグローバル変数を使っているため、
完全にはカプセル化できていない。

次回の更新からは、ワンステップ実行の実装を目指すことにする。
このため、eval_sentence にて用いている再帰をスタックで除去する。



2021-05-27
v1.1 としてリリース。
GUI 版を作成した。
また、GUI版では一つの文しか受け付けないようにし、
複数の文を入力するときには
複合文 begin～end を使うようにした
（文法的にはこちらの方が正しい）。



2021-02-06 
v1.0 としてリリース。
結果出力のインデントが、9行目にも関わらず
10行目のものとなっていたので修正した。



2021-02-05
eval_sentence を再帰版に戻した。
また、procedure の呼び出しを「文」ではなく「式」として扱うようにした。



2021-01-25
While言語のインタプリタ eval（再帰的定義版）の例を
少しだけ複雑にした。


2021-01-14
print文にて文字列の表示が行えなかったので修正した。


2020-12-20
配布版に含まれている不要なライブラリを削除した。


2020-01-20
配列の表示を Python dic形式から
[a,b,c] 形式に変更した
（pretty_print_val が担当）。
[今後の課題]
・手続き呼び出しの入れ子を許可するようにする。


2020-01-18
文を解釈する eval_sentence() から
再帰呼び出しを除去した。
これは、テキストの万能プログラム U から
再帰呼び出しを除去する方法のチェックも兼ねている。
[今後の課題]
・配列の表示を [a,b,c] にする。
・手続き呼び出しの入れ子を許可するようにする。


2019-11-25
procedure の呼出し処理におけるローカル変数の保存を
stack で行うことにした
今後の課題：
配列の表示を [a,b,c] にする。
配列に対しての組み込み関数 len, reverse, push, pop を用意する。


2018-11-02
配列、文字列を追加
IF-THEN-ELSE が解釈されないバグを解消






以上
----------------------------------------------------------------
